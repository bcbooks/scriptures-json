{"version":3,"file":"slice_pipe.js","sourceRoot":"","sources":["../../../../../modules/@angular/common/src/pipes/slice_pipe.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;OAEI,EAAC,IAAI,EAAgB,MAAM,eAAe;OAC1C,EAAC,WAAW,EAAC,MAAM,sBAAsB;OACzC,EAAC,aAAa,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAC,MAAM,gBAAgB;OACjE,EAAC,wBAAwB,EAAC,MAAM,+BAA+B;AAEtE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2CG;AAGH;IAAA;IAmBA,CAAC;IAlBC,6BAAS,GAAT,UAAU,KAAU,EAAE,KAAa,EAAE,GAAkB;QAAlB,mBAAkB,GAAlB,UAAkB;QACrD,EAAE,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;QACjC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC1B,MAAM,IAAI,wBAAwB,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;QACvD,CAAC;QACD,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACpB,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;QAChD,CAAC;QACD,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;IAC9C,CAAC;IAEO,4BAAQ,GAAhB,UAAiB,GAAQ,IAAa,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACxE,oBAAU,GAA0B;QAC3C,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,EAAC,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,KAAK,EAAC,EAAG,EAAE;KACrD,CAAC;IACF,kBAAkB;IACX,wBAAc,GAA6D,EACjF,CAAC;IACF,gBAAC;AAAD,CAAC,AAnBD,IAmBC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Pipe, PipeTransform} from '@angular/core';\nimport {ListWrapper} from '../facade/collection';\nimport {StringWrapper, isArray, isBlank, isString} from '../facade/lang';\nimport {InvalidPipeArgumentError} from './invalid_pipe_argument_error';\n\n/**\n * @ngModule CommonModule\n * @whatItDoes Creates a new List or String containing a subset (slice) of the elements.\n * @howToUse `array_or_string_expression | slice:start[:end]`\n * @description\n *\n * Where the input expression is a `List` or `String`, and:\n * - `start`: The starting index of the subset to return.\n *   - **a positive integer**: return the item at `start` index and all items after\n *     in the list or string expression.\n *   - **a negative integer**: return the item at `start` index from the end and all items after\n *     in the list or string expression.\n *   - **if positive and greater than the size of the expression**: return an empty list or string.\n *   - **if negative and greater than the size of the expression**: return entire list or string.\n * - `end`: The ending index of the subset to return.\n *   - **omitted**: return all items until the end.\n *   - **if positive**: return all items before `end` index of the list or string.\n *   - **if negative**: return all items before `end` index from the end of the list or string.\n *\n * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`\n * and `String.prototype.slice()`.\n *\n * When operating on a [List], the returned list is always a copy even when all\n * the elements are being returned.\n *\n * When operating on a blank value, the pipe returns the blank value.\n *\n * ## List Example\n *\n * This `ngFor` example:\n *\n * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}\n *\n * produces the following:\n *\n *     <li>b</li>\n *     <li>c</li>\n *\n * ## String Examples\n *\n * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}\n *\n * @stable\n */\n\n\nexport class SlicePipe implements PipeTransform {\n  transform(value: any, start: number, end: number = null): any {\n    if (isBlank(value)) return value;\n    if (!this.supports(value)) {\n      throw new InvalidPipeArgumentError(SlicePipe, value);\n    }\n    if (isString(value)) {\n      return StringWrapper.slice(value, start, end);\n    }\n    return ListWrapper.slice(value, start, end);\n  }\n\n  private supports(obj: any): boolean { return isString(obj) || isArray(obj); }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Pipe, args: [{name: 'slice', pure: false}, ] },\n];\n/** @nocollapse */\nstatic ctorParameters: ({type: any, decorators?: DecoratorInvocation[]}|null)[] = [\n];\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}